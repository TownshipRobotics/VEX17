/* Feel free to ignore this stuff. Skip down beyond this section. */ 
#pragma config(Sensor, in1,             pot,           sensorPotentiometer)
#pragma config(Motor,  port1,           armLeft,       tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontRight,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           backLeft,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           backRight,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           claw,          tmotorNone, openLoop)
#pragma config(Motor,  port10,          armRight,      tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//



/*****   COMMENTARY ON COMMENTS   *****/

// THIS IS A COMMENT ON ONE LINE

/* This is a
   comment on multiple lines. */

/* Anything can go in here, except for the
   closing symbol --> */

// Please use comments in your code to explain what it's doing.
// I beg you. <3



/*****   EXAMPLES OF MAKING YOUR OWN METHODS   *****/

int myMethod(int param) {
    double myOtherNumber = 0.6;

    // Multiply param with myOtherNumber, and then "cast" it to an
    // int (truncate it):
    param = (int) (param * myOtherNumber);

    // Since this method header says it'll return an int, you have
    // to return an int:
    return param;
}

void voidMethod() {
    // Do the things ???
    // You can use other methods in here!
    int returnedValue = myMethod(5);

    // ^ What will returnedValue be holding?

    /* Imagine I actually have statements here because I'm
       totally not a lazy bum and this voidMethod actually
       does something */
    
    // Notice no return statement! Void so nothing to return
}



/*****   EXAMPLE MAIN METHOD   *****/

/* This is kinda like a weird method. When the robot is turned on,
   task main() is called.
   This is where you put what you actually want the robot to do. */

task main()
{
    /* Motors can be given a power to set their motion.
       Powers can be in the range of -128 to 128 (inclusive),
       where 128 is very fast clockwise, 0 is no motion, and
       -128 is very fast counterclockwise.

       To set a motor's power, reference motor[<name of motor>]
       just like a variable. */
 
    // Set motor frontRight to power 50
    motor[frontRight] = 50;


    /* When the program terminates (basically once the last
       statement is run) the robot shuts everything off,
       including the motors. If you let the program terminate
       at this point, then the motor would never spin because
       it would immediately turn off again.

       To prevent the program from continuing (and in this case
       from terminating) you can use a sleep statement: */

    sleep(5000); // Sleeps for 5000ms (5 seconds)

    /* After five seconds the program will resume, and since it
       immediately reaches the end of the program, everything
       shuts off including the motor. You could manually stop
       the motor at this point with motor[frontRight] = 0; but
       here there's no need. */
}